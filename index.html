<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="preload" href="/fonts/Calistoga-Regular.ttf" as="font" type="font/ttf" crossorigin>
    <link rel="preload" href="/fonts/Quicksand-Semibold.ttf" as="font" type="font/ttf" crossorigin>
    <title>myQuest</title>

    <link rel="icon" href="/images/favicon.ico" sizes="any">
    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="manifest" href="/manifest.json">

    <style>
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            padding: 0;
            margin: 0;
            pointer-events: none;
            background: rgb(26, 15, 31);
        }
        /* Import the font using @font-face */
        @font-face {
          font-family: 'Calistoga';
          font-style: normal;
          font-weight: 400;
          src: url('/fonts/Calistoga-Regular.ttf') format('truetype');
        }

        @font-face {
          font-family: 'Quicksand';
          font-style: normal;
          font-weight: 400;
          src: url('/fonts/Quicksand-Semibold.ttf') format('truetype');
        }

        body > canvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        div, a, img {
            position: absolute;
            box-sizing: border-box;
            -webkit-backface-visibility: hidden;
            pointer-events: none;
        }

        a {
            cursor: pointer;
            pointer-events: all;
        }

        .text {
            pointer-events: all;
            white-space: pre;
        }

        /* TODO special exception for text selection in debug tools */
        [id='2067877626'] > * {
            pointer-events: none !important;
        }

        /* Custom Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 12px; /* Adjust width as needed */
        }

        ::-webkit-scrollbar-track {
            background: #2d1f33; /* COLOR_CARD */
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #942f4a, #b13658); /* COLOR_PRIMARY and COLOR_PRIMARY_HOVER */
            border-radius: 6px;
            border: 3px solid #2d1f33; /* Match COLOR_CARD for an inset effect */
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #b13658, #ff6b97); /* COLOR_PRIMARY_HOVER to COLOR_ACCENT */
        }

        ::-webkit-scrollbar-corner {
            background: #1a0f1f; /* COLOR_BACKGROUND */
        }

        /* Optional: Add styling for overflow elements */
        .scroll-container {
            scrollbar-color: #942f4a #2d1f33; /* Thumb and track colors for Firefox */
            scrollbar-width: thin; /* Thin scrollbar for Firefox */
        }

    </style>
</head>
<script type="module">

var Module = {};
var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.error.bind(console);

var printCharBuffers = [null,[],[]];
var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;

const CLAY_RENDER_COMMAND_TYPE_NONE = 0;
const CLAY_RENDER_COMMAND_TYPE_RECTANGLE = 1;
const CLAY_RENDER_COMMAND_TYPE_BORDER = 2;
const CLAY_RENDER_COMMAND_TYPE_TEXT = 3;
const CLAY_RENDER_COMMAND_TYPE_IMAGE = 4;
const CLAY_RENDER_COMMAND_TYPE_SCISSOR_START = 5;
const CLAY_RENDER_COMMAND_TYPE_SCISSOR_END = 6;
const CLAY_RENDER_COMMAND_TYPE_CUSTOM = 7;
const GLOBAL_FONT_SCALING_FACTOR = 0.8;
let renderCommandSize = 0;
let scratchSpaceAddress = 8;
let heapSpaceAddress = 0;
let memoryDataView;
let textDecoder = new TextDecoder("utf-8");
let previousFrameTime;
let fontsById = [
    'Quicksand',
    'Calistoga',
    'Quicksand',
    'Quicksand',
    'Quicksand',
];
let elementCache = {};
let imageCache = {};
let colorDefinition = { type: 'struct', members: [
    {name: 'r', type: 'float' },
    {name: 'g', type: 'float' },
    {name: 'b', type: 'float' },
    {name: 'a', type: 'float' },
]};
let stringDefinition = { type: 'struct', members: [
    {name: 'length', type: 'uint32_t' },
    {name: 'chars', type: 'uint32_t' },
]};
let borderDefinition = { type: 'struct', members: [
    {name: 'width', type: 'uint32_t'},
    {name: 'color', ...colorDefinition},
]};
let cornerRadiusDefinition = { type: 'struct', members: [
    {name: 'topLeft', type: 'float'},
    {name: 'topRight', type: 'float'},
    {name: 'bottomLeft', type: 'float'},
    {name: 'bottomRight', type: 'float'},
]};
let rectangleConfigDefinition = { name: 'rectangle', type: 'struct', members: [
    { name: 'color', ...colorDefinition },
    { name: 'cornerRadius', ...cornerRadiusDefinition },
    { name: 'link', ...stringDefinition },
    { name: 'cursorPointer', type: 'uint8_t' },
]};
let borderConfigDefinition = { name: 'text', type: 'struct', members: [
    { name: 'left', ...borderDefinition },
    { name: 'right', ...borderDefinition },
    { name: 'top', ...borderDefinition },
    { name: 'bottom', ...borderDefinition },
    { name: 'betweenChildren', ...borderDefinition },
    { name: 'cornerRadius', ...cornerRadiusDefinition }
]};
let textConfigDefinition = { name: 'text', type: 'struct', members: [
   { name: 'textColor', ...colorDefinition },
   { name: 'fontId', type: 'uint16_t' },
   { name: 'fontSize', type: 'uint16_t' },
   { name: 'letterSpacing', type: 'uint16_t' },
   { name: 'lineSpacing', type: 'uint16_t' },
   { name: 'wrapMode', type: 'uint32_t' },
   { name: 'disablePointerEvents', type: 'uint8_t' }
]};
let scrollConfigDefinition = { name: 'text', type: 'struct', members: [
    { name: 'horizontal', type: 'bool' },
    { name: 'vertical', type: 'bool' },
]};
let imageConfigDefinition = { name: 'image', type: 'struct', members: [
    { name: 'imageData', type: 'uint32_t' },
    { name: 'sourceDimensions', type: 'struct', members: [
        { name: 'width', type: 'float' },
        { name: 'height', type: 'float' },
    ]},
    { name: 'sourceURL', ...stringDefinition }
]};
let customConfigDefinition = { name: 'custom', type: 'struct', members: [
    { name: 'customData', type: 'uint32_t' },
]}
let renderCommandDefinition = {
    name: 'CLay_RenderCommand',
    type: 'struct',
    members: [
        { name: 'boundingBox', type: 'struct', members: [
            { name: 'x', type: 'float' },
            { name: 'y', type: 'float' },
            { name: 'width', type: 'float' },
            { name: 'height', type: 'float' },
        ]},
        { name: 'config', type: 'uint32_t'},
        { name: 'text', ...stringDefinition },
        { name: 'id', type: 'uint32_t' },
        { name: 'commandType', type: 'uint32_t', },
    ]
};

function getStructTotalSize(definition) {
    switch(definition.type) {
        case 'union':
        case 'struct': {
            let totalSize = 0;
            for (const member of definition.members) {
                let result = getStructTotalSize(member);
                if (definition.type === 'struct') {
                    totalSize += result;
                } else {
                    totalSize = Math.max(totalSize, result);
                }
            }
            return totalSize;
        }
        case 'float': return 4;
        case 'uint32_t': return 4;
        case 'uint16_t': return 2;
        case 'uint8_t': return 1;
        case 'bool': return 1;
        default: {
            throw "Unimplemented C data type " + definition.type
        }
    }
}

function readStructAtAddress(address, definition) {
    switch(definition.type) {
        case 'union':
        case 'struct': {
            let struct = { __size: 0 };
            for (const member of definition.members) {
                let result = readStructAtAddress(address, member);
                struct[member.name] = result;
                if (definition.type === 'struct') {
                    struct.__size += result.__size;
                    address += result.__size;
                } else {
                    struct.__size = Math.max(struct.__size, result.__size);
                }
            }
            return struct;
        }
        case 'float': return { value: memoryDataView.getFloat32(address, true), __size: 4 };
        case 'uint32_t': return { value: memoryDataView.getUint32(address, true), __size: 4 };
        case 'uint16_t': return { value: memoryDataView.getUint16(address, true), __size: 2 };
        case 'uint8_t': return { value: memoryDataView.getUint8(address, true), __size: 1 };
        case 'bool': return { value: memoryDataView.getUint8(address, true), __size: 1 };
        default: {
            throw "Unimplemented C data type " + definition.type
        }
    }
}

function getTextDimensions(text, font) {
    // re-use canvas object for better performance
    window.canvasContext.font = font;
    let metrics = window.canvasContext.measureText(text);
    return { width: metrics.width, height: metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent };
}

function createMainArena(arenaStructAddress, arenaMemoryAddress) {
    let memorySize = instance.exports.Clay_MinMemorySize();
    // Last arg is address to store return value
    instance.exports.Clay_CreateArenaWithCapacityAndMemory(arenaStructAddress, memorySize, arenaMemoryAddress);
}
async function init() {
    await Promise.all(fontsById.map(f => document.fonts.load(`12px "${f}"`)));
    window.htmlRoot = document.body.appendChild(document.createElement('div'));
    window.canvasRoot = document.body.appendChild(document.createElement('canvas'));
    window.canvasContext = window.canvasRoot.getContext("2d");
    window.mousePositionXThisFrame = 0;
    window.mousePositionYThisFrame = 0;
    window.mouseWheelXThisFrame = 0;
    window.mouseWheelYThisFrame = 0;
    window.touchDown = false;
    window.arrowKeyDownPressedThisFrame = false;
    window.arrowKeyUpPressedThisFrame = false;
    let zeroTimeout = null;
    document.addEventListener("wheel", (event) => {
        window.mouseWheelXThisFrame = event.deltaX * -0.1;
        window.mouseWheelYThisFrame = event.deltaY * -0.1;
        clearTimeout(zeroTimeout);
        zeroTimeout = setTimeout(() => {
            window.mouseWheelXThisFrame = 0;
            window.mouseWheelYThisFrame = 0;
        }, 10);
    });

    function handleTouch (event) {
        if (event.touches.length === 1) {
            window.touchDown = true;
            let target = event.target;
            let scrollTop = 0;
            let scrollLeft = 0;
            let activeRendererIndex = memoryDataView.getUint32(instance.exports.ACTIVE_RENDERER_INDEX.value, true);
            while (activeRendererIndex !== 1 && target) {
                scrollLeft += target.scrollLeft;
                scrollTop += target.scrollTop;
                target = target.parentElement;
            }
            window.mousePositionXThisFrame = event.changedTouches[0].pageX + scrollLeft;
            window.mousePositionYThisFrame = event.changedTouches[0].pageY + scrollTop;
        }
    }

    document.addEventListener("touchstart", handleTouch);
    document.addEventListener("touchmove", handleTouch);
    document.addEventListener("touchend", () => {
        window.touchDown = false;
        window.mousePositionXThisFrame = 0;
        window.mousePositionYThisFrame = 0;
    })

    document.addEventListener("mousemove", (event) => {
        let target = event.target;
        let scrollTop = 0;
        let scrollLeft = 0;
        let activeRendererIndex = memoryDataView.getUint32(instance.exports.ACTIVE_RENDERER_INDEX.value, true);
        while (activeRendererIndex !== 1 && target) {
            scrollLeft += target.scrollLeft;
            scrollTop += target.scrollTop;
            target = target.parentElement;
        }
        window.mousePositionXThisFrame = event.x + scrollLeft;
        window.mousePositionYThisFrame = event.y + scrollTop;
    });

    document.addEventListener("mousedown", (event) => {
        window.mouseDown = true;
        window.mouseDownThisFrame = true;
    });

    document.addEventListener("mouseup", (event) => {
        window.mouseDown = false;
    });

    document.addEventListener("keydown", (event) => {
        if (event.key === "ArrowDown") {
            window.arrowKeyDownPressedThisFrame = true;
        }
        if (event.key === "ArrowUp") {
            window.arrowKeyUpPressedThisFrame = true;
        }
        if (event.key === "d") {
            window.dKeyPressedThisFrame = true;
        }
    });
    // Add these before the importObject:
    var printCharBuffers = [null,[],[]];

    var out = (text) => { console.log(text); };
    var err = (text) => { console.error(text); };

    var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;
        while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

        if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
        }
        var str = '';
        while (idx < endPtr) {
            var u0 = heapOrArray[idx++];
            if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
            var u1 = heapOrArray[idx++] & 63;
            if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
            var u2 = heapOrArray[idx++] & 63;
            if ((u0 & 0xF0) == 0xE0) {
                u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
            } else {
                u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
            }
            if (u0 < 0x10000) {
                str += String.fromCharCode(u0);
            } else {
                var ch = u0 - 0x10000;
                str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
            }
        }
        return str;
    };

    var printChar = (stream, curr) => {
        var buffer = printCharBuffers[stream];
        if (!buffer) {
            console.error("No buffer for stream:", stream); // Debug
            return;
        }
        if (curr === 0 || curr === 10) {
            let output = UTF8ArrayToString(buffer);
            (stream === 1 ? out : err)(output);
            buffer.length = 0;
        } else {
            buffer.push(curr);
        }
    };
    
    const importObject = {
        env: {
            // Add this function to convert a tm struct to a Unix timestamp
            _mktime_js: (tmPtr) => {
                // Read the tm struct from memory
                const tm_sec = memoryDataView.getInt32(tmPtr, true);       // Seconds (0-59)
                const tm_min = memoryDataView.getInt32(tmPtr + 4, true);   // Minutes (0-59)
                const tm_hour = memoryDataView.getInt32(tmPtr + 8, true);  // Hours (0-23)
                const tm_mday = memoryDataView.getInt32(tmPtr + 12, true); // Day of the month (1-31)
                const tm_mon = memoryDataView.getInt32(tmPtr + 16, true);  // Month (0-11, 0 = January)
                const tm_year = memoryDataView.getInt32(tmPtr + 20, true); // Year (years since 1900)
                const tm_wday = memoryDataView.getInt32(tmPtr + 24, true); // Day of the week (0-6, 0 = Sunday)
                const tm_yday = memoryDataView.getInt32(tmPtr + 28, true); // Day of the year (0-365)
                const tm_isdst = memoryDataView.getInt32(tmPtr + 32, true); // Daylight saving time flag

                // Convert the tm struct to a JavaScript Date object
                const date = new Date(
                    tm_year + 1900, // Year (add 1900 to get the full year)
                    tm_mon,         // Month (0-11)
                    tm_mday,        // Day of the month (1-31)
                    tm_hour,        // Hours (0-23)
                    tm_min,         // Minutes (0-59)
                    tm_sec          // Seconds (0-59)
                );

                // Convert the Date object to a Unix timestamp (seconds since the epoch)
                const timestamp = Math.floor(date.getTime() / 1000);

                return timestamp; // Return the Unix timestamp
            },
            // Add this function to handle heap resizing
            emscripten_resize_heap: (requestedSize) => {
                console.log(`Resizing heap to ${requestedSize} bytes`);
                const oldMemory = importObject.env.memory;
                const oldBuffer = oldMemory.buffer;

                // Calculate the new size (round up to the nearest 64KB page)
                const PAGE_SIZE = 65536; // 64KB
                const newSize = Math.ceil(requestedSize / PAGE_SIZE) * PAGE_SIZE;

                // Create a new memory instance with the new size
                const newMemory = new WebAssembly.Memory({
                    initial: Math.ceil(newSize / PAGE_SIZE),
                    maximum: oldMemory.maximum,
                });

                // Copy the old memory contents to the new memory
                const newBuffer = newMemory.buffer;
                new Uint8Array(newBuffer).set(new Uint8Array(oldBuffer));

                // Replace the old memory with the new memory
                importObject.env.memory = newMemory;
                memoryDataView = new DataView(newBuffer);

                // Notify Emscripten that the memory has grown
                if (importObject.env.emscripten_notify_memory_growth) {
                    importObject.env.emscripten_notify_memory_growth(0); // 0 is the memory index
                }

                return 1; // Return 1 to indicate success
            },
            _tzset_js: () => {
                console.log("_tzset_js called (no-op)");
            },
            _emscripten_memcpy_js: (dest, src, num) => {
                const destArray = new Uint8Array(importObject.env.memory.buffer, dest, num);
                const srcArray = new Uint8Array(importObject.env.memory.buffer, src, num);
                destArray.set(srcArray);
                return dest;
            },
            emscripten_date_now: () => Date.now(),
            memory: new WebAssembly.Memory({ initial: 256, maximum: 512 }),
            table: new WebAssembly.Table({ initial: 0, element: 'anyfunc' }),
            emscripten_asm_const_int: (x) => x,
            emscripten_notify_memory_growth: (memoryIndex) => {
                const buffer = importObject.env.memory.buffer;
                memoryDataView = new DataView(buffer);
                console.log(`Memory grew, updated memory view for memory index: ${memoryIndex}`);
            },
            printf: msg => console.log(msg),
            __localtime_js: (time_low, time_high, tmPtr) => {
                const time = (time_low + (time_high * 2 ** 32)) / 1000; // Convert to seconds
                const date = new Date(time * 1000);

                memoryDataView.setInt32(tmPtr, date.getSeconds(), true);
                memoryDataView.setInt32(tmPtr + 4, date.getMinutes(), true);
                memoryDataView.setInt32(tmPtr + 8, date.getHours(), true);
                memoryDataView.setInt32(tmPtr + 12, date.getDate(), true);
                memoryDataView.setInt32(tmPtr + 16, date.getMonth(), true);
                memoryDataView.setInt32(tmPtr + 20, date.getFullYear() - 1900, true);
                memoryDataView.setInt32(tmPtr + 24, date.getDay(), true);

                const yday = Math.floor((date - new Date(date.getFullYear(), 0, 1)) / (24 * 60 * 60 * 1000));
                memoryDataView.setInt32(tmPtr + 28, yday, true);

                const timezoneOffset = -date.getTimezoneOffset() * 60;
                memoryDataView.setInt32(tmPtr + 36, timezoneOffset, true);

                const isDst = new Date(date.getFullYear(), 6, 1).getTimezoneOffset() !== timezoneOffset;
                memoryDataView.setInt32(tmPtr + 32, isDst ? 1 : 0, true);
            },
            JS_SaveHabits: (collectionPtr) => {
                try {
                    const memory = new DataView(instance.exports.memory.buffer);
                    const HABIT_SIZE = 12056;
                    const HABIT_DAY_SIZE = 12;
                    const MAX_HABITS = 10;

                    const habitsCount = memory.getUint32(collectionPtr + (HABIT_SIZE * MAX_HABITS), true);
                    const activeHabitId = memory.getUint32(collectionPtr + (HABIT_SIZE * MAX_HABITS) + 4, true);
                    
                    const habitsData = {
                        habits: [],
                        active_habit_id: activeHabitId
                    };

                    for (let i = 0; i < habitsCount; i++) {
                        const habitOffset = collectionPtr + (i * HABIT_SIZE);
                        
                        // Read name
                        let name = "";
                        for (let j = 0; j < 32; j++) {
                            const char = memory.getUint8(habitOffset + j);
                            if (char === 0) break;
                            name += String.fromCharCode(char);
                        }

                        const id = memory.getUint32(habitOffset + 32, true);
                        const colorOffset = habitOffset + 36;
                        const daysOffset = habitOffset + 52;
                        const daysCount = memory.getUint32(habitOffset + 12052, true);

                        const habit = {
                            id,
                            name,
                            color: {
                                r: memory.getFloat32(colorOffset, true),
                                g: memory.getFloat32(colorOffset + 4, true),
                                b: memory.getFloat32(colorOffset + 8, true),
                                a: memory.getFloat32(colorOffset + 12, true)
                            },
                            calendar_days: []
                        };

                        for (let j = 0; j < daysCount; j++) {
                            const dayOffset = daysOffset + (j * HABIT_DAY_SIZE);
                            habit.calendar_days.push({
                                date: memory.getUint32(dayOffset, true),
                                day_index: memory.getUint32(dayOffset + 4, true),
                                completed: memory.getUint8(dayOffset + 8) !== 0
                            });
                        }

                        habitsData.habits.push(habit);
                    }

                    localStorage.setItem("habitsData", JSON.stringify(habitsData));
                } catch (error) {
                    console.error("Error in JS_SaveHabits:", error);
                    console.error(error.stack);
                }
            },
            deleteHabitFunction: (collectionPtr, habit_id) => {
                try {
                    const stored = localStorage.getItem("habitsData");
                    if (!stored) return;

                    let habitsData = JSON.parse(stored);
                    
                    // Find and remove the habit
                    const habitIndex = habitsData.habits.findIndex(h => h.id === habit_id);
                    if (habitIndex === -1) return;
                    
                    habitsData.habits.splice(habitIndex, 1);
                    
                    // Update remaining habit IDs to match their array positions
                    habitsData.habits.forEach((habit, index) => {
                        habit.id = index;
                    });
                    
                    // Update active_habit_id if needed
                    if (habitsData.active_habit_id === habit_id) {
                        if (habitsData.habits.length > 0) {
                            if (habitIndex > 0) {
                                habitsData.active_habit_id = habitIndex - 1;
                            } else {
                                habitsData.active_habit_id = 0;
                            }
                        }
                    } else if (habitsData.active_habit_id > habit_id) {
                        habitsData.active_habit_id--;
                    }
                    
                    localStorage.setItem("habitsData", JSON.stringify(habitsData));
                } catch (error) {
                    console.error("Error in deleteHabitFunction:", error);
                }
            },
            addNewHabitFunction: (collectionPtr) => {
                try {
                    const stored = localStorage.getItem("habitsData");
                    let habitsData = stored ? JSON.parse(stored) : { habits: [], active_habit_id: 0 };
                    
                    const newHabitId = habitsData.habits.length;
                    
                    // Create new habit with default values
                    const newHabit = {
                        id: newHabitId,
                        name: `Habit ${newHabitId + 1}`,
                        color: {
                            r: 148,  // Default primary color values
                            g: 47,
                            b: 74,
                            a: 255
                        },
                        calendar_days: []
                    };
                    
                    habitsData.habits.push(newHabit);
                    habitsData.active_habit_id = newHabitId;
                    
                    localStorage.setItem("habitsData", JSON.stringify(habitsData));
                } catch (error) {
                    console.error("Error in addNewHabitFunction:", error);
                }
            },
            JS_SaveTodos: (collectionPtr) => {
                try {
                    const memory = new DataView(instance.exports.memory.buffer);
                    const TODO_SIZE = 1052; // Assuming similar structure to habits
                    const MAX_TODOS = 50;

                    const todosCount = memory.getUint32(collectionPtr + (TODO_SIZE * MAX_TODOS), true);
                    
                    const todosData = {
                        todos: [],
                        active_day: ""
                    };

                    // Read active day
                    const activeDayOffset = collectionPtr + (TODO_SIZE * MAX_TODOS) + 4;
                    let activeDay = "";
                    for (let j = 0; j < 10; j++) {
                        const char = memory.getUint8(activeDayOffset + j);
                        if (char === 0) break;
                        activeDay += String.fromCharCode(char);
                    }
                    todosData.active_day = activeDay;

                    for (let i = 0; i < todosCount; i++) {
                        const todoOffset = collectionPtr + (i * TODO_SIZE);
                        
                        // Read text
                        let text = "";
                        for (let j = 0; j < 256; j++) {
                            const char = memory.getUint8(todoOffset + j);
                            if (char === 0) break;
                            text += String.fromCharCode(char);
                        }

                        const id = memory.getUint32(todoOffset + 256, true);
                        const position = memory.getUint32(todoOffset + 260, true);
                        const completed = memory.getUint8(todoOffset + 264) !== 0;
                        const createdAt = Number(memory.getBigUint64(todoOffset + 268, true));
                        
                        // Read day
                        let day = "";
                        for (let j = 0; j < 10; j++) {
                            const char = memory.getUint8(todoOffset + 276 + j);
                            if (char === 0) break;
                            day += String.fromCharCode(char);
                        }

                        const todo = {
                            id,
                            text,
                            position,
                            completed,
                            created_at: createdAt,
                            day
                        };

                        todosData.todos.push(todo);
                    }

                    localStorage.setItem("todosData", JSON.stringify(todosData));
                } catch (error) {
                    console.error("Error in JS_SaveTodos:", error);
                    console.error(error.stack);
                }
            },

            JS_LoadTodos: (collectionPtr) => {
                try {
                    const stored = localStorage.getItem("todosData");
                    if (!stored) {
                        console.log("No stored todos data found");
                        return;
                    }

                    const todosData = JSON.parse(stored);
                    const memory = new DataView(instance.exports.memory.buffer);
                    const TODO_SIZE = 1052;
                    const MAX_TODOS = 50;

                    // Write todos count
                    memory.setUint32(collectionPtr + (TODO_SIZE * MAX_TODOS), todosData.todos.length, true);

                    // Write active day
                    const activeDayOffset = collectionPtr + (TODO_SIZE * MAX_TODOS) + 4;
                    const encoder = new TextEncoder();
                    const activeDayBytes = encoder.encode(todosData.active_day);
                    for (let j = 0; j < 10; j++) {
                        memory.setUint8(activeDayOffset + j, j < activeDayBytes.length ? activeDayBytes[j] : 0);
                    }

                    // Write each todo
                    for (let i = 0; i < todosData.todos.length; i++) {
                        const todo = todosData.todos[i];
                        const todoOffset = collectionPtr + (i * TODO_SIZE);

                        // Write text
                        const textBytes = encoder.encode(todo.text);
                        for (let j = 0; j < 256; j++) {
                            memory.setUint8(todoOffset + j, j < textBytes.length ? textBytes[j] : 0);
                        }

                        // Write id
                        memory.setUint32(todoOffset + 256, todo.id, true);

                        // Write position
                        memory.setUint32(todoOffset + 260, todo.position, true);

                        // Write completed
                        memory.setUint8(todoOffset + 264, todo.completed ? 1 : 0);

                        // Write created_at
                        memory.setBigUint64(todoOffset + 268, BigInt(todo.created_at), true);

                        // Write day
                        const dayBytes = encoder.encode(todo.day);
                        for (let j = 0; j < 10; j++) {
                            memory.setUint8(todoOffset + 276 + j, j < dayBytes.length ? dayBytes[j] : 0);
                        }
                    }
                } catch (error) {
                    console.error("Error in JS_LoadTodos:", error);
                    console.error(error.stack);
                }
            },
            JS_LoadHabits: (collectionPtr) => {
                try {
                    const stored = localStorage.getItem("habitsData");
                    if (!stored) {
                        console.log("No stored habits data found");
                        return;
                    }

                    const habitsData = JSON.parse(stored);
                    const memory = new DataView(instance.exports.memory.buffer);
                    const HABIT_SIZE = 12056;
                    const HABIT_DAY_SIZE = 12;
                    const MAX_HABITS = 10;

                    // Write habits count and active habit id
                    memory.setUint32(collectionPtr + (HABIT_SIZE * MAX_HABITS), habitsData.habits.length, true);
                    memory.setUint32(collectionPtr + (HABIT_SIZE * MAX_HABITS) + 4, habitsData.active_habit_id, true);


                    // Write each habit
                    for (let i = 0; i < habitsData.habits.length; i++) {
                        const habit = habitsData.habits[i];
                        const habitOffset = collectionPtr + (i * HABIT_SIZE);

                        // Write name
                        const encoder = new TextEncoder();
                        const nameBytes = encoder.encode(habit.name);
                        for (let j = 0; j < 32; j++) {
                            memory.setUint8(habitOffset + j, j < nameBytes.length ? nameBytes[j] : 0);
                        }

                        // Write id
                        memory.setUint32(habitOffset + 32, habit.id, true);

                        // Write color
                        const colorOffset = habitOffset + 36;
                        memory.setFloat32(colorOffset, habit.color.r, true);
                        memory.setFloat32(colorOffset + 4, habit.color.g, true);
                        memory.setFloat32(colorOffset + 8, habit.color.b, true);
                        memory.setFloat32(colorOffset + 12, habit.color.a, true);

                        // Write calendar days
                        const daysOffset = habitOffset + 52;
                        for (let j = 0; j < habit.calendar_days.length; j++) {
                            const day = habit.calendar_days[j];
                            const dayOffset = daysOffset + (j * HABIT_DAY_SIZE);
                            memory.setUint32(dayOffset, day.date, true);
                            memory.setUint32(dayOffset + 4, day.day_index, true);
                            memory.setUint8(dayOffset + 8, day.completed ? 1 : 0);
                        }

                        // Write days count
                        memory.setUint32(habitOffset + 12052, habit.calendar_days.length, true);
                    }
                } catch (error) {
                    console.error("Error in JS_LoadHabits:", error);
                    console.error(error.stack);
                }
            },
            JS_AddTodo: (collectionPtr, textPtr) => {
                try {
                    const stored = localStorage.getItem("todosData");
                    let todosData = stored ? JSON.parse(stored) : { todos: [], active_day: "Monday" };
                    
                    // Read the text from memory
                    let text = "";
                    const textDecoder = new TextDecoder();
                    for (let i = 0; i < 256; i++) {  // MAX_TODO_TEXT
                        const char = memoryDataView.getUint8(textPtr + i);
                        if (char === 0) break;
                        text += String.fromCharCode(char);
                    }
                    
                    const newTodo = {
                        id: todosData.todos.length,
                        text: text,
                        position: todosData.todos.length,
                        completed: false,
                        created_at: Date.now(),
                        day: todosData.active_day
                    };
                    
                    todosData.todos.push(newTodo);
                    localStorage.setItem("todosData", JSON.stringify(todosData));
                } catch (error) {
                    console.error("Error in addTodoFunction:", error);
                }
            },

            JS_DeleteTodo: (collectionPtr, todoId) => {
                try {
                    const stored = localStorage.getItem("todosData");
                    if (!stored) return;

                    let todosData = JSON.parse(stored);
                    todosData.todos = todosData.todos.filter(todo => todo.id !== todoId);
                    
                    // Update remaining todo IDs and positions
                    todosData.todos.forEach((todo, index) => {
                        todo.id = index;
                        todo.position = index;
                    });
                    
                    localStorage.setItem("todosData", JSON.stringify(todosData));
                } catch (error) {
                    console.error("Error in deleteTodoFunction:", error);
                }
            },

            JS_ToggleTodo: (collectionPtr, todoId) => {
                try {
                    const stored = localStorage.getItem("todosData");
                    if (!stored) return;

                    let todosData = JSON.parse(stored);
                    const todo = todosData.todos.find(t => t.id === todoId);
                    if (todo) {
                        todo.completed = !todo.completed;
                        localStorage.setItem("todosData", JSON.stringify(todosData));
                    }
                } catch (error) {
                    console.error("Error in toggleTodoFunction:", error);
                }
            },

            JS_SetActiveDay: (collectionPtr, dayPtr) => {
                try {
                    const stored = localStorage.getItem("todosData");
                    let todosData = stored ? JSON.parse(stored) : { todos: [], active_day: "Monday" };
                    
                    // Read the day from memory
                    let day = "";
                    for (let i = 0; i < 10; i++) {
                        const char = memoryDataView.getUint8(dayPtr + i);
                        if (char === 0) break;
                        day += String.fromCharCode(char);
                    }
                    
                    todosData.active_day = day;
                    localStorage.setItem("todosData", JSON.stringify(todosData));
                } catch (error) {
                    console.error("Error in setActiveDayFunction:", error);
                }
            },
        },
        wasi_snapshot_preview1: {
            proc_exit: () => {},
            fd_write: (fd, iov, iovcnt, pnum) => {
                var num = 0;
                for (var i = 0; i < iovcnt; i++) {
                    var ptr = memoryDataView.getUint32(iov + i*8, true);
                    var len = memoryDataView.getUint32(iov + i*8 + 4, true);
                    for (var j = 0; j < len; j++) {
                        let byte = memoryDataView.getUint8(ptr + j);
                        printChar(fd, byte);
                    }
                    num += len;
                }
                memoryDataView.setUint32(pnum, num, true);
                return 0;
            },
            fd_close: () => 0,
            fd_seek: () => 0,
            fd_read: () => 0,
            environ_sizes_get: () => 0,
            environ_get: () => 0,
            clock_time_get: (id, precision, timePtr) => {
                const nowNs = BigInt(Date.now()) * BigInt(1e6);
                memoryDataView.setBigUint64(timePtr, nowNs, true);
                return 0; // Success
            },

            random_get: (bufferPtr, bufferLen) => {
                const buffer = new Uint8Array(importObject.env.memory.buffer, bufferPtr, bufferLen);
                crypto.getRandomValues(buffer);
                return 0;
            }
        },
        clay: {
            measureTextFunction: (addressOfDimensions, textToMeasure, addressOfConfig) => {
                let stringLength = memoryDataView.getUint32(textToMeasure, true);
                let pointerToString = memoryDataView.getUint32(textToMeasure + 4, true);
                let textConfig = readStructAtAddress(addressOfConfig, textConfigDefinition);
                let textDecoder = new TextDecoder("utf-8");
                let text = textDecoder.decode(memoryDataView.buffer.slice(pointerToString, pointerToString + stringLength));
                let sourceDimensions = getTextDimensions(text, `${Math.round(textConfig.fontSize.value * GLOBAL_FONT_SCALING_FACTOR)}px ${fontsById[textConfig.fontId.value]}`);
                memoryDataView.setFloat32(addressOfDimensions, sourceDimensions.width, true);
                memoryDataView.setFloat32(addressOfDimensions + 4, sourceDimensions.height, true);
            },
            queryScrollOffsetFunction: (addressOfOffset, elementId) => {
                let container = document.getElementById(elementId.toString());
                if (container) {
                    memoryDataView.setFloat32(addressOfOffset, -container.scrollLeft, true);
                    memoryDataView.setFloat32(addressOfOffset + 4, -container.scrollTop, true);
                }
            }
        }
    };
    const { instance } = await WebAssembly.instantiateStreaming(fetch("/index.wasm"), importObject);

    // Set up the memory and other parameters
    memoryDataView = new DataView(new Uint8Array(instance.exports.memory.buffer).buffer);
    scratchSpaceAddress = instance.exports.__heap_base.value;
    heapSpaceAddress = instance.exports.__heap_base.value + 1024;
    let arenaAddress = scratchSpaceAddress + 8;
    window.instance = instance;

    // Initialize memory and pass parameters to the WebAssembly instance
    createMainArena(arenaAddress, heapSpaceAddress);
    memoryDataView.setFloat32(instance.exports.__heap_base.value, window.innerWidth, true);
    memoryDataView.setFloat32(instance.exports.__heap_base.value + 4, window.innerHeight, true);

    // Call initialization function
    instance.exports.Clay_Initialize(arenaAddress, instance.exports.__heap_base.value);

    // Log the exports to see what is available
    console.log(instance.exports);

    // Continue with other logic
    renderCommandSize = getStructTotalSize(renderCommandDefinition);
    renderLoop();


}

function MemoryIsDifferent(one, two, length) {
    for (let i = 0; i < length; i++) {
        if (one[i] !== two[i]) {
            return true;
        }
    }
    return false;
}

function renderLoopHTML() {
    let capacity = memoryDataView.getUint32(scratchSpaceAddress, true);
    let length = memoryDataView.getUint32(scratchSpaceAddress + 4, true);
    let arrayOffset = memoryDataView.getUint32(scratchSpaceAddress + 8, true);
    let scissorStack = [{ nextAllocation: { x: 0, y: 0 }, element: htmlRoot, nextElementIndex: 0 }];
    let previousId = 0;
    for (let i = 0; i < length; i++, arrayOffset += renderCommandSize) {
        let entireRenderCommandMemory = new Uint32Array(memoryDataView.buffer.slice(arrayOffset, arrayOffset + renderCommandSize));
        let renderCommand = readStructAtAddress(arrayOffset, renderCommandDefinition);
        let parentElement = scissorStack[scissorStack.length - 1];
        let element = null;
        let isMultiConfigElement = previousId === renderCommand.id.value;
        if (!elementCache[renderCommand.id.value]) {
            let elementType = 'div';
            switch (renderCommand.commandType.value) {
                case CLAY_RENDER_COMMAND_TYPE_RECTANGLE: {
                    if (readStructAtAddress(renderCommand.config.value, rectangleConfigDefinition).link.length.value > 0) {
                        elementType = 'a';
                    }
                    break;
                }
                case CLAY_RENDER_COMMAND_TYPE_IMAGE: {
                    elementType = 'img'; break;
                }
                default: break;
            }
            element = document.createElement(elementType);
            element.id = renderCommand.id.value;
            if (renderCommand.commandType.value === CLAY_RENDER_COMMAND_TYPE_SCISSOR_START) {
                element.style.overflow = 'hidden';
            }
            elementCache[renderCommand.id.value] = {
                exists: true,
                element: element,
                previousMemoryCommand: new Uint8Array(0),
                previousMemoryConfig: new Uint8Array(0),
                previousMemoryText: new Uint8Array(0)
            };
        }

        let elementData = elementCache[renderCommand.id.value];
        element = elementData.element;
        if (!isMultiConfigElement && Array.prototype.indexOf.call(parentElement.element.children, element) !== parentElement.nextElementIndex) {
            if (parentElement.nextElementIndex === 0) {
                parentElement.element.insertAdjacentElement('afterbegin', element);
            } else {
                parentElement.element.childNodes[Math.min(parentElement.nextElementIndex - 1, parentElement.element.childNodes.length - 1)].insertAdjacentElement('afterend', element);
            }
        }

        elementData.exists = true;
        // Don't get me started. Cheaper to compare the render command memory than to update HTML elements
        let dirty = MemoryIsDifferent(elementData.previousMemoryCommand, entireRenderCommandMemory, renderCommandSize) && !isMultiConfigElement;
        if (!isMultiConfigElement) {
            parentElement.nextElementIndex++;
        }

        previousId = renderCommand.id.value;

        elementData.previousMemoryCommand = entireRenderCommandMemory;
        let offsetX = scissorStack.length > 0 ? scissorStack[scissorStack.length - 1].nextAllocation.x : 0;
        let offsetY = scissorStack.length > 0 ? scissorStack[scissorStack.length - 1].nextAllocation.y : 0;
        if (dirty) {
            element.style.transform = `translate(${Math.round(renderCommand.boundingBox.x.value - offsetX)}px, ${Math.round(renderCommand.boundingBox.y.value - offsetY)}px)`
            element.style.width = Math.round(renderCommand.boundingBox.width.value) + 'px';
            element.style.height = Math.round(renderCommand.boundingBox.height.value) + 'px';
        }

        switch(renderCommand.commandType.value) {
            case (CLAY_RENDER_COMMAND_TYPE_NONE): {
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_RECTANGLE): {
                let config = readStructAtAddress(renderCommand.config.value, rectangleConfigDefinition);
                let configMemory = new Uint8Array(memoryDataView.buffer.slice(renderCommand.config.value, renderCommand.config.value + config.__size));
                let linkContents = config.link.length.value > 0 ? textDecoder.decode(new Uint8Array(memoryDataView.buffer.slice(config.link.chars.value, config.link.chars.value + config.link.length.value))) : 0;
                memoryDataView.setUint32(0, renderCommand.id.value, true);
                if (linkContents.length > 0 && (window.mouseDownThisFrame || window.touchDown) && instance.exports.Clay_PointerOver(0)) {
                    window.location.href = linkContents;
                }
                if (!dirty && !MemoryIsDifferent(configMemory, elementData.previousMemoryConfig, config.__size)) {
                    break;
                }
                if (linkContents.length > 0) {
                    element.href = linkContents;
                }
                element.style.cursor = 'default';

                if (linkContents.length > 0 || config.cursorPointer.value) {
                    element.style.pointerEvents = 'all';
                    element.style.cursor = 'pointer';
                }
                
                elementData.previousMemoryConfig = configMemory;
                let color = config.color;
                element.style.backgroundColor = `rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`;
                if (config.cornerRadius.topLeft.value > 0) {
                    element.style.borderTopLeftRadius = config.cornerRadius.topLeft.value + 'px';
                }
                if (config.cornerRadius.topRight.value > 0) {
                    element.style.borderTopRightRadius = config.cornerRadius.topRight.value + 'px';
                }
                if (config.cornerRadius.bottomLeft.value > 0) {
                    element.style.borderBottomLeftRadius = config.cornerRadius.bottomLeft.value + 'px';
                }
                if (config.cornerRadius.bottomRight.value > 0) {
                    element.style.borderBottomRightRadius = config.cornerRadius.bottomRight.value + 'px';
                }
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_BORDER): {
                let config = readStructAtAddress(renderCommand.config.value, borderConfigDefinition);
                let configMemory = new Uint8Array(memoryDataView.buffer.slice(renderCommand.config.value, renderCommand.config.value + config.__size));
                if (!dirty && !MemoryIsDifferent(configMemory, elementData.previousMemoryConfig, config.__size)) {
                    break;
                }
                elementData.previousMemoryConfig = configMemory;
                if (config.left.width.value > 0) {
                    let color = config.left.color;
                    element.style.borderLeft = `${config.left.width.value}px solid rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`
                }
                if (config.right.width.value > 0) {
                    let color = config.right.color;
                    element.style.borderRight = `${config.right.width.value}px solid rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`
                }
                if (config.top.width.value > 0) {
                    let color = config.top.color;
                    element.style.borderTop = `${config.top.width.value}px solid rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`
                }
                if (config.bottom.width.value > 0) {
                    let color = config.bottom.color;
                    element.style.borderBottom = `${config.bottom.width.value}px solid rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`
                }
                if (config.cornerRadius.topLeft.value > 0) {
                    element.style.borderTopLeftRadius = config.cornerRadius.topLeft.value + 'px';
                }
                if (config.cornerRadius.topRight.value > 0) {
                    element.style.borderTopRightRadius = config.cornerRadius.topRight.value + 'px';
                }
                if (config.cornerRadius.bottomLeft.value > 0) {
                    element.style.borderBottomLeftRadius = config.cornerRadius.bottomLeft.value + 'px';
                }
                if (config.cornerRadius.bottomRight.value > 0) {
                    element.style.borderBottomRightRadius = config.cornerRadius.bottomRight.value + 'px';
                }
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_TEXT): {
                let config = readStructAtAddress(renderCommand.config.value, textConfigDefinition);
                let configMemory = new Uint8Array(memoryDataView.buffer.slice(renderCommand.config.value, renderCommand.config.value + config.__size));
                let textContents = renderCommand.text;
                let stringContents = new Uint8Array(memoryDataView.buffer.slice(textContents.chars.value, textContents.chars.value + textContents.length.value));
                if (MemoryIsDifferent(configMemory, elementData.previousMemoryConfig, config.__size)) {
                    element.className = 'text';
                    let textColor = config.textColor;
                    let fontSize = Math.round(config.fontSize.value * GLOBAL_FONT_SCALING_FACTOR);
                    element.style.color = `rgba(${textColor.r.value}, ${textColor.g.value}, ${textColor.b.value}, ${textColor.a.value})`;
                    element.style.fontFamily = fontsById[config.fontId.value];
                    element.style.fontSize = fontSize + 'px';
                    element.style.pointerEvents = config.disablePointerEvents.value ? 'none' : 'all';
                    element.style.userSelect = config.disablePointerEvents.value ? 'none' : 'all';
                    elementData.previousMemoryConfig = configMemory;
                }
                if (stringContents.length !== elementData.previousMemoryText.length || MemoryIsDifferent(stringContents, elementData.previousMemoryText, stringContents.length)) {
                    element.innerHTML = textDecoder.decode(stringContents);
                }
                elementData.previousMemoryText = stringContents;
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_SCISSOR_START): {
                scissorStack.push({ nextAllocation: { x: renderCommand.boundingBox.x.value, y: renderCommand.boundingBox.y.value }, element, nextElementIndex: 0 });
                let config = readStructAtAddress(renderCommand.config.value, scrollConfigDefinition);
                if (config.horizontal.value) {
                    element.style.overflowX = 'scroll';
                    element.style.pointerEvents = 'auto';
                }
                if (config.vertical.value) {
                    element.style.overflowY = 'scroll';
                    element.style.pointerEvents = 'auto';
                }
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_SCISSOR_END): {
                scissorStack.splice(scissorStack.length - 1, 1);
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_IMAGE): {
                let config = readStructAtAddress(renderCommand.config.value, imageConfigDefinition);
                let srcContents = new Uint8Array(memoryDataView.buffer.slice(config.sourceURL.chars.value, config.sourceURL.chars.value + config.sourceURL.length.value));
                if (srcContents.length !== elementData.previousMemoryText.length || MemoryIsDifferent(srcContents, elementData.previousMemoryText, srcContents.length)) {
                    element.src = textDecoder.decode(srcContents);
                }
                elementData.previousMemoryText = srcContents;
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_CUSTOM): break;
        }
    }

    for (const key of Object.keys(elementCache)) {
        if (elementCache[key].exists) {
            elementCache[key].exists = false;
        } else {
            elementCache[key].element.remove();
            delete elementCache[key];
        }
    }
}

function renderLoopCanvas() {
// Note: Rendering to canvas needs to be scaled up by window.devicePixelRatio in both width and height.
// e.g. if we're working on a device where devicePixelRatio is 2, we need to render
// everything at width^2 x height^2 resolution, then scale back down with css to get the correct pixel density.
    let capacity = memoryDataView.getUint32(scratchSpaceAddress, true);
    let length = memoryDataView.getUint32(scratchSpaceAddress + 4, true);
    let arrayOffset = memoryDataView.getUint32(scratchSpaceAddress + 8, true);
    window.canvasRoot.width = window.innerWidth * window.devicePixelRatio;
    window.canvasRoot.height = window.innerHeight * window.devicePixelRatio;
    window.canvasRoot.style.width = window.innerWidth + 'px';
    window.canvasRoot.style.height = window.innerHeight + 'px';
    let ctx = window.canvasContext;
    let scale = window.devicePixelRatio;
    for (let i = 0; i < length; i++, arrayOffset += renderCommandSize) {
        let renderCommand = readStructAtAddress(arrayOffset, renderCommandDefinition);
        let boundingBox = renderCommand.boundingBox;
        switch(renderCommand.commandType.value) {
            case (CLAY_RENDER_COMMAND_TYPE_NONE): {
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_RECTANGLE): {
                let config = readStructAtAddress(renderCommand.config.value, rectangleConfigDefinition);
                let color = config.color;
                ctx.beginPath();
                window.canvasContext.fillStyle = `rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`;
                window.canvasContext.roundRect(
                    boundingBox.x.value * scale, // x
                    boundingBox.y.value * scale, // y
                    boundingBox.width.value * scale, // width
                    boundingBox.height.value * scale,
                    [config.cornerRadius.topLeft.value * scale, config.cornerRadius.topRight.value * scale, config.cornerRadius.bottomRight.value * scale, config.cornerRadius.bottomLeft.value * scale]) // height;
                ctx.fill();
                ctx.closePath();
                // Handle link clicks
                let linkContents = config.link.length.value > 0 ? textDecoder.decode(new Uint8Array(memoryDataView.buffer.slice(config.link.chars.value, config.link.chars.value + config.link.length.value))) : 0;
                memoryDataView.setUint32(0, renderCommand.id.value, true);
                if (linkContents.length > 0 && (window.mouseDownThisFrame || window.touchDown) && instance.exports.Clay_PointerOver(0)) {
                    window.location.href = linkContents;
                }
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_BORDER): {
                let config = readStructAtAddress(renderCommand.config.value, borderConfigDefinition);
                ctx.beginPath();
                ctx.moveTo(boundingBox.x.value * scale, boundingBox.y.value * scale);
                // Top Left Corner
                if (config.cornerRadius.topLeft.value > 0) {
                    let lineWidth = config.top.width.value;
                    let halfLineWidth = lineWidth / 2;
                    ctx.moveTo((boundingBox.x.value + halfLineWidth) * scale, (boundingBox.y.value + config.cornerRadius.topLeft.value + halfLineWidth) * scale);
                    let color = config.top.color;
                    ctx.lineWidth = lineWidth * scale;
                    ctx.strokeStyle = `rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`;
                    ctx.arcTo((boundingBox.x.value + halfLineWidth) * scale, (boundingBox.y.value + halfLineWidth) * scale, (boundingBox.x.value + config.cornerRadius.topLeft.value + halfLineWidth) * scale, (boundingBox.y.value + halfLineWidth) * scale, config.cornerRadius.topLeft.value * scale);
                    ctx.stroke();
                }
                // Top border
                if (config.top.width.value > 0) {
                    let lineWidth = config.top.width.value;
                    let halfLineWidth = lineWidth / 2;
                    let color = config.top.color;
                    ctx.lineWidth = lineWidth * scale;
                    ctx.strokeStyle = `rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`;
                    ctx.moveTo((boundingBox.x.value + config.cornerRadius.topLeft.value + halfLineWidth) * scale, (boundingBox.y.value + halfLineWidth) * scale);
                    ctx.lineTo((boundingBox.x.value + boundingBox.width.value - config.cornerRadius.topRight.value - halfLineWidth) * scale, (boundingBox.y.value + halfLineWidth) * scale);
                    ctx.stroke();
                }
                // Top Right Corner
                if (config.cornerRadius.topRight.value > 0) {
                    let lineWidth = config.top.width.value;
                    let halfLineWidth = lineWidth / 2;
                    ctx.moveTo((boundingBox.x.value + boundingBox.width.value - config.cornerRadius.topRight.value - halfLineWidth) * scale, (boundingBox.y.value + halfLineWidth) * scale);
                    let color = config.top.color;
                    ctx.lineWidth = lineWidth * scale;
                    ctx.strokeStyle = `rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`;
                    ctx.arcTo((boundingBox.x.value + boundingBox.width.value - halfLineWidth) * scale, (boundingBox.y.value + halfLineWidth) * scale, (boundingBox.x.value + boundingBox.width.value - halfLineWidth) * scale, (boundingBox.y.value + config.cornerRadius.topRight.value + halfLineWidth) * scale, config.cornerRadius.topRight.value * scale);
                    ctx.stroke();
                }
                // Right border
                if (config.right.width.value > 0) {
                    let color = config.right.color;
                    let lineWidth = config.right.width.value;
                    let halfLineWidth = lineWidth / 2;
                    ctx.lineWidth = lineWidth * scale;
                    ctx.strokeStyle = `rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`;
                    ctx.moveTo((boundingBox.x.value + boundingBox.width.value - halfLineWidth) * scale, (boundingBox.y.value + config.cornerRadius.topRight.value + halfLineWidth) * scale);
                    ctx.lineTo((boundingBox.x.value + boundingBox.width.value - halfLineWidth) * scale, (boundingBox.y.value + boundingBox.height.value - config.cornerRadius.topRight.value - halfLineWidth) * scale);
                    ctx.stroke();
                }
                // Bottom Right Corner
                if (config.cornerRadius.bottomRight.value > 0) {
                    let color = config.top.color;
                    let lineWidth = config.top.width.value;
                    let halfLineWidth = lineWidth / 2;
                    ctx.moveTo((boundingBox.x.value + boundingBox.width.value - halfLineWidth) * scale, (boundingBox.y.value + boundingBox.height.value - config.cornerRadius.bottomRight.value - halfLineWidth) * scale);
                    ctx.lineWidth = lineWidth * scale;
                    ctx.strokeStyle = `rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`;
                    ctx.arcTo((boundingBox.x.value + boundingBox.width.value - halfLineWidth) * scale, (boundingBox.y.value + boundingBox.height.value - halfLineWidth) * scale, (boundingBox.x.value + boundingBox.width.value - config.cornerRadius.bottomRight.value - halfLineWidth) * scale, (boundingBox.y.value + boundingBox.height.value - halfLineWidth) * scale, config.cornerRadius.bottomRight.value * scale);
                    ctx.stroke();
                }
                // Bottom Border
                if (config.bottom.width.value > 0) {
                    let color = config.bottom.color;
                    let lineWidth = config.bottom.width.value;
                    let halfLineWidth = lineWidth / 2;
                    ctx.lineWidth = lineWidth * scale;
                    ctx.strokeStyle = `rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`;
                    ctx.moveTo((boundingBox.x.value + config.cornerRadius.bottomLeft.value + halfLineWidth) * scale, (boundingBox.y.value + boundingBox.height.value - halfLineWidth) * scale);
                    ctx.lineTo((boundingBox.x.value + boundingBox.width.value - config.cornerRadius.bottomRight.value - halfLineWidth) * scale, (boundingBox.y.value + boundingBox.height.value - halfLineWidth) * scale);
                    ctx.stroke();
                }
                // Bottom Left Corner
                if (config.cornerRadius.bottomLeft.value > 0) {
                    let color = config.bottom.color;
                    let lineWidth = config.bottom.width.value;
                    let halfLineWidth = lineWidth / 2;
                    ctx.moveTo((boundingBox.x.value + config.cornerRadius.bottomLeft.value + halfLineWidth) * scale, (boundingBox.y.value + boundingBox.height.value - halfLineWidth) * scale);
                    ctx.lineWidth = lineWidth * scale;
                    ctx.strokeStyle = `rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`;
                    ctx.arcTo((boundingBox.x.value + halfLineWidth) * scale, (boundingBox.y.value + boundingBox.height.value - halfLineWidth) * scale, (boundingBox.x.value + halfLineWidth) * scale, (boundingBox.y.value + boundingBox.height.value - config.cornerRadius.bottomLeft.value - halfLineWidth) * scale, config.cornerRadius.bottomLeft.value * scale);
                    ctx.stroke();
                }
                // Left Border
                if (config.left.width.value > 0) {
                    let color = config.left.color;
                    let lineWidth = config.left.width.value;
                    let halfLineWidth = lineWidth / 2;
                    ctx.lineWidth = lineWidth * scale;
                    ctx.strokeStyle = `rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`;
                    ctx.moveTo((boundingBox.x.value + halfLineWidth) * scale, (boundingBox.y.value + boundingBox.height.value - config.cornerRadius.bottomLeft.value - halfLineWidth) * scale);
                    ctx.lineTo((boundingBox.x.value + halfLineWidth) * scale, (boundingBox.y.value + config.cornerRadius.bottomRight.value + halfLineWidth) * scale);
                    ctx.stroke();
                }
                ctx.closePath();
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_TEXT): {
                let config = readStructAtAddress(renderCommand.config.value, textConfigDefinition);
                let textContents = renderCommand.text;
                let stringContents = new Uint8Array(memoryDataView.buffer.slice(textContents.chars.value, textContents.chars.value + textContents.length.value));
                let fontSize = config.fontSize.value * GLOBAL_FONT_SCALING_FACTOR * scale;
                ctx.font = `${fontSize}px ${fontsById[config.fontId.value]}`;
                let color = config.textColor;
                ctx.textBaseline = 'middle';
                ctx.fillStyle = `rgba(${color.r.value}, ${color.g.value}, ${color.b.value}, ${color.a.value / 255})`;
                ctx.fillText(textDecoder.decode(stringContents), boundingBox.x.value * scale, (boundingBox.y.value + boundingBox.height.value / 2 + 1) * scale);
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_SCISSOR_START): {
                window.canvasContext.save();
                window.canvasContext.beginPath();
                window.canvasContext.rect(boundingBox.x.value * scale, boundingBox.y.value * scale, boundingBox.width.value * scale, boundingBox.height.value * scale);
                window.canvasContext.clip();
                window.canvasContext.closePath();
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_SCISSOR_END): {
                window.canvasContext.restore();
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_IMAGE): {
                let config = readStructAtAddress(renderCommand.config.value, imageConfigDefinition);
                let src = textDecoder.decode(new Uint8Array(memoryDataView.buffer.slice(config.sourceURL.chars.value, config.sourceURL.chars.value + config.sourceURL.length.value)));
                if (!imageCache[src]) {
                    imageCache[src] = {
                        image: new Image(),
                        loaded: false,
                    }
                    imageCache[src].image.onload = () => imageCache[src].loaded = true;
                    imageCache[src].image.src = src;
                } else if (imageCache[src].loaded) {
                    ctx.drawImage(imageCache[src].image, boundingBox.x.value * scale, boundingBox.y.value * scale, boundingBox.width.value * scale, boundingBox.height.value * scale);
                }
                break;
            }
            case (CLAY_RENDER_COMMAND_TYPE_CUSTOM): break;
        }
    }
}

function renderLoop(currentTime) {
    const elapsed = currentTime - previousFrameTime;
    previousFrameTime = currentTime;
    let activeRendererIndex = memoryDataView.getUint32(instance.exports.ACTIVE_RENDERER_INDEX.value, true);
    if (activeRendererIndex === 0) {
        instance.exports.UpdateDrawFrame(scratchSpaceAddress, window.innerWidth, window.innerHeight, 0, 0, window.mousePositionXThisFrame, window.mousePositionYThisFrame, window.touchDown, window.mouseDown, 0, 0, window.dKeyPressedThisFrame, elapsed / 1000);
    } else {
        instance.exports.UpdateDrawFrame(scratchSpaceAddress, window.innerWidth, window.innerHeight, window.mouseWheelXThisFrame, window.mouseWheelYThisFrame, window.mousePositionXThisFrame, window.mousePositionYThisFrame, window.touchDown, window.mouseDown, window.arrowKeyDownPressedThisFrame, window.arrowKeyUpPressedThisFrame, window.dKeyPressedThisFrame, elapsed / 1000);
    }
    let rendererChanged = activeRendererIndex !== window.previousActiveRendererIndex;
    switch (activeRendererIndex) {
        case 0: {
            renderLoopHTML();
            if (rendererChanged) {
                window.htmlRoot.style.display = 'block';
                window.canvasRoot.style.display = 'none';
            }
            break;
        }
        case 1: {
            renderLoopCanvas();
            if (rendererChanged) {
                window.htmlRoot.style.display = 'none';
                window.canvasRoot.style.display = 'block';
            }
            break;
        }
    }
    window.previousActiveRendererIndex = activeRendererIndex;
    requestAnimationFrame(renderLoop);
    window.mouseDownThisFrame = false;
    window.arrowKeyUpPressedThisFrame = false;
    window.arrowKeyDownPressedThisFrame = false;
    window.dKeyPressedThisFrame = false;
}
init();
</script>
<body>
</body>
</html>